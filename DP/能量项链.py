'''
在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，
这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，
通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。
如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为（Mars单位），
新产生的珠子的头标记为m，尾标记为n。
　　需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序
得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。例如：设N=4，4颗珠子的头标记与尾标记依次为
(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。
则第4、1两颗珠子聚合后释放的能量为：(4⊕1)=10*2*3=60。这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：
((4⊕1)⊕2)⊕3）
=10*2*3+10*3*5+10*5*10=710。
【输入文件】
　　输入文件energy.in的第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i
至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。
【输出文件】
　　输出文件energy.out只有一行，是一个正整数E（E≤2.1*10^9），为一个最优聚合顺序所释放的总能量。
【输入样例1】
4
2 3 5 10
【输出样例1】
710

【输入样例2】
6
2 8 6 5 3 4
【输出样例2】
908
'''


class Solution:
    def __init__(self):
        pass

    def energy_neckLace(self, n, necklaces):
        arr = [0]
        arr += necklaces
        arr += necklaces
        print(arr)
        dp = [[0 for _ in range(2 * n + 2)] for _ in range(2 * n + 2)]
        for len1 in range(2, n + 1):
            for i in range(1, n * 2 + 1 - len1):
                j = i + len1 - 1
                for k in range(i, j):
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + arr[i] * arr[j + 1] * arr[k + 1])
        for i in dp:
            print(i)


solve = Solution()
n = 6
arr = [2, 8, 6, 5, 3, 4]
result = solve.energy_neckLace(n, arr)
print(result)
